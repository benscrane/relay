import type { Endpoint, MockRule } from '@mockd/shared';

/**
 * Generate a cURL command for an endpoint.
 */
export function endpointToCurl(
  baseUrl: string,
  endpoint: Endpoint,
  method: string = 'GET'
): string {
  const url = `${baseUrl}${endpoint.path}`;
  const parts = ['curl'];

  if (method !== 'GET') {
    parts.push('-X', method);
  }

  parts.push(`'${url}'`);

  return parts.join(' ');
}

/**
 * Export format for a single endpoint with its rules.
 */
export interface EndpointExport {
  path: string;
  statusCode: number;
  responseBody: string;
  delay: number;
  rateLimit: number;
  rules?: Array<{
    name: string | null;
    priority: number;
    matchMethod: string | null;
    matchPath: string | null;
    matchHeaders: Record<string, string> | null;
    responseStatus: number;
    responseHeaders: Record<string, string> | null;
    responseBody: string;
    responseDelayMs: number;
    isActive: boolean;
  }>;
}

/**
 * Export format for a full project.
 */
export interface ProjectExport {
  version: '1.0';
  exportedAt: string;
  projectName: string;
  endpoints: EndpointExport[];
}

/**
 * Convert endpoints (with optional rules) to a JSON export format.
 */
export function endpointsToJson(
  projectName: string,
  endpoints: Endpoint[],
  rulesMap?: Map<string, MockRule[]>
): ProjectExport {
  return {
    version: '1.0',
    exportedAt: new Date().toISOString(),
    projectName,
    endpoints: endpoints.map(ep => {
      const exp: EndpointExport = {
        path: ep.path,
        statusCode: ep.statusCode,
        responseBody: ep.responseBody,
        delay: ep.delay,
        rateLimit: ep.rateLimit,
      };

      const rules = rulesMap?.get(ep.id);
      if (rules && rules.length > 0) {
        exp.rules = rules.map(r => ({
          name: r.name,
          priority: r.priority,
          matchMethod: r.matchMethod,
          matchPath: r.matchPath,
          matchHeaders: r.matchHeaders,
          responseStatus: r.responseStatus,
          responseHeaders: r.responseHeaders,
          responseBody: r.responseBody,
          responseDelayMs: r.responseDelayMs,
          isActive: r.isActive,
        }));
      }

      return exp;
    }),
  };
}

/**
 * Convert endpoints to a minimal OpenAPI 3.0 spec.
 */
export function endpointsToOpenApi(
  projectName: string,
  baseUrl: string,
  endpoints: Endpoint[],
  rulesMap?: Map<string, MockRule[]>
): object {
  const paths: Record<string, Record<string, object>> = {};

  for (const ep of endpoints) {
    // Convert mockd path params (/:param) to OpenAPI style (/{param})
    const openApiPath = ep.path.replace(/:(\w+)/g, '{$1}');

    const rules = rulesMap?.get(ep.id) || [];
    // Determine which methods this endpoint handles
    const methods = new Set<string>();
    for (const rule of rules) {
      if (rule.matchMethod) {
        methods.add(rule.matchMethod.toLowerCase());
      }
    }
    // Always include GET if no methods specified
    if (methods.size === 0) {
      methods.add('get');
    }

    const pathItem: Record<string, object> = {};

    for (const method of methods) {
      let responseBody: string;
      let statusCode: number;

      // Find the matching rule for this method
      const matchingRule = rules.find(r => r.matchMethod?.toLowerCase() === method && r.isActive);
      if (matchingRule) {
        responseBody = matchingRule.responseBody;
        statusCode = matchingRule.responseStatus;
      } else {
        responseBody = ep.responseBody;
        statusCode = ep.statusCode;
      }

      let exampleValue: unknown;
      try {
        exampleValue = JSON.parse(responseBody);
      } catch {
        exampleValue = responseBody;
      }

      const operation: Record<string, unknown> = {
        summary: `${method.toUpperCase()} ${ep.path}`,
        responses: {
          [String(statusCode)]: {
            description: 'Mock response',
            content: {
              'application/json': {
                example: exampleValue,
              },
            },
          },
        },
      };

      // Add path parameters if present
      const paramMatches = ep.path.match(/:(\w+)/g);
      if (paramMatches) {
        operation.parameters = paramMatches.map(p => ({
          name: p.substring(1),
          in: 'path',
          required: true,
          schema: { type: 'string' },
        }));
      }

      pathItem[method] = operation;
    }

    paths[openApiPath] = pathItem;
  }

  return {
    openapi: '3.0.3',
    info: {
      title: projectName,
      version: '1.0.0',
      description: `Mock API generated by mockd`,
    },
    servers: [{ url: baseUrl }],
    paths,
  };
}

/**
 * Trigger a file download in the browser.
 */
export function downloadJson(data: object, filename: string): void {
  const json = JSON.stringify(data, null, 2);
  const blob = new Blob([json], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}
